# نتیجه - PR #4 (feat: Add a solution to solve the problem.)
نویسنده: `Hessam8008`
لینک: https://github.com/dotin-challenge/dashboard-service-optimization/pull/4
زبان: فارسی | [English](./result.md)

## خلاصه
مسیر مینیمال `GET /{key}` که یک رشته شامل زمان فعلی و آبجکت کش‌شده `DashboardItem` برمی‌گرداند. از `IMemoryCache.GetOrCreateAsync` با `Sliding=30m` و `Absolute=60m` استفاده شده است. کار سنگین با تأخیر ۳ ثانیه در `DashboardItem.CreateAsync` شبیه‌سازی شده است. کد کوچک و بین `DashboardRepo`، `DashboardItem` و پیکربندی برنامه تقسیم شده است.

طبق README، هر خواندن باید اعتبار را ۳۰ دقیقه تمدید کند. علاوه بر تضاد بالقوه Absolute+Sliding، این پیاده‌سازی کنترل Stampede ندارد و در صورت Miss همزمان ممکن است چندین بازتولید رخ دهد.

## امتیازدهی
| معیار | وزن | امتیاز (0-100) | وزنی | توضیحات |
|------|-----|-----------------|------|---------|
| درستی پیاده‌سازی | 40% | 55 | 22.0 | عدم کنترل Stampede؛ تضاد Absolute+Sliding با قانون TTL |
| کیفیت کد و خوانایی | 25% | 80 | 20.0 | کد کوچک و مجزا؛ ایرادهای جزئی نوشتاری |
| همزمانی و مدیریت خطا | 10% | 60 | 6.0 | بدون قفل/لاگ؛ نبود مدیریت خطا |
| کارایی و رفتار کش | 10% | 60 | 6.0 | امکان بازتولید چندگانه؛ سقف Absolute غیرضروری |
| مستندسازی | 5% | 20 | 1.0 | README موجود نیست |
| سرعت ارسال | 5% | 0 | 0.0 | خارج از سه نفر اول |
| مجموع |  |  | 55.0 |  |

## نقاط قوت
- استفاده از `IMemoryCache` با Sliding=30m مطابق نیت مسئله.
- کد ساده و قابل فهم؛ جداسازی مسئولیت‌ها.
- استفاده از `CancellationToken` در کار سنگین.

## موارد قابل بهبود
- افزودن کنترل Stampede (مثلاً `SemaphoreSlim` + double-check).
- بازنگری سیاست TTL: sliding-only یا refresh absolute روی خواندن.
- پاسخ ساختاریافته (JSON) و مدیریت خطا/لاگ پایه.
- افزودن README با نحوه اجرا و منطق طراحی.

## توضیحات امتیاز
- Correctness: کنترل Stampede ندارد و TTL با نیت README همراستا نیست.
- Quality: ساختار ساده و تمیز.
- Concurrency/Error: بدون قفل و مدیریت خطا.
- Performance: احتمال محاسبه تکراری در بار همزمان.
- Docs: نبود مستند اجرا.


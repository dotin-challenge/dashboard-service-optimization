# نتیجه - PR #10 (High-Traffic Dashboard Optimization - H.Shamekhi)
نویسنده: `agaheman`
لینک: https://github.com/dotin-challenge/dashboard-service-optimization/pull/10
زبان: فارسی | [English](./result.md)

## خلاصه
Minimal API با `IMemoryCache` و یک `SemaphoreSlim` سراسری برای جلوگیری از Stampede. در cache-miss، داده با تأخیر ۳ ثانیه تولید و با `Absolute=1h` کش می‌شود. در cache-hit، ورودی کش با `Absolute=30m` بازنویسی می‌شود که عملاً TTL را کوتاه می‌کند (به‌جای تمدید ۳۰ دقیقه‌ای بر اساس خواندن). Sliding استفاده نشده است.

## امتیازدهی
| معیار | وزن | امتیاز (0-100) | وزنی | توضیحات |
|------|-----|-----------------|------|---------|
| درستی پیاده‌سازی | 40% | 55 | 22.0 | روی hit Absolute=30m تنظیم می‌شود؛ Sliding ندارد |
| کیفیت کد و خوانایی | 25% | 82 | 20.5 | سرویس و endpoint واضح؛ لاگ‌گذاری مناسب |
| همزمانی و مدیریت خطا | 10% | 85 | 8.5 | قفل سراسری + double-check؛ پاسخ problem در خطا |
| کارایی و رفتار کش | 10% | 75 | 7.5 | بدون Sliding؛ کوتاه‌شدن TTL روی خواندن |
| مستندسازی | 5% | 40 | 2.0 | README محلی موجود نیست |
| سرعت ارسال | 5% | 0 | 0.0 | خارج از سه نفر اول |
| مجموع |  |  | 60.5 |  |

## نقاط قوت
- جلوگیری از Stampede با قفل + double-check.
- پاسخ JSON ساختاریافته؛ لاگ زمان تولید.

## موارد قابل بهبود
- هم‌راستاسازی TTL: اعتبار ۱ ساعت و Sliding ۳۰ دقیقه‌ای روی هر خواندن.
- قفل‌های per-key و callback حذف کش برای مشاهده‌پذیری.
- افزودن README با نحوه اجرا و آزمون.

## توضیحات امتیاز
- Correctness: رفتار TTL با README متفاوت است؛ Sliding پیکربندی نشده.
- Quality: کد تمیز و خوانا.
- Concurrency/Error: قفل و نگاشت خطا مناسب.
- Performance: به‌دلیل نبود Sliding، رفتار پیش‌بینی‌ناپذیرتر.
- Docs: نبود مستندات محلی.


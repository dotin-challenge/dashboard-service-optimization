# بهینه‌سازی سرویس داشبورد پربازدید

[![Difficulty](https://img.shields.io/badge/difficulty-متوسط-orange)]()
[![Languages](https://img.shields.io/badge/languages-C%23-informational)]()
[![Deadline](https://img.shields.io/badge/deadline-2025--12--02-critical)]()

> هدف: طراحی یک مکانیزم کش مقاوم برای سرویس داشبورد تا از «هجوم همزمان» درخواست‌ها هنگام انقضای داده جلوگیری شود.

---

## فهرست مطالب

* [پیش‌نیازها](#پیشنیازها)
* [شرح مسئله](#شرح-مسئله)
* [قوانین و محدودیت‌ها](#قوانین-و-محدودیتها)
* [نمونه رفتار مورد انتظار](#نمونه-رفتار-مورد-انتظار)
* [نحوه اجرا و تست](#نحوه-اجرا-و-تست)
* [نحوه ارسال (PR)](#نحوه-ارسال-pr)
* [معیارهای ارزیابی](#معیارهای-ارزیابی)
* [زمان‌بندی](#زمانبندی)
* [راه‌های ارتباطی](#راههای-ارتباطی)

---

## پیش‌نیازها

* زبان مجاز: **C#**
* نسخه پیشنهادی: `.NET 6+`
* سیستم‌عامل: آزاد (Windows / Linux / macOS)
* آشنایی با:

  * `IMemoryCache` برای کش داده‌ها
  * کنترل همزمانی (Thread-safety)
  * پیاده‌سازی سرویس یا برنامه کنسولی ساده

---

## شرح مسئله

شما به عنوان یک **توسعه‌دهنده بک‌اند** در یک شرکت نرم‌افزاری Enterprise فعالیت می‌کنید. یکی از پرکاربردترین بخش‌های سیستم، **سرویس داشبورد**ی است که داده‌های تحلیلی کلیدی را نمایش می‌دهد. تولید این داده‌ها نیازمند یک پردازش سنگین است که چندین ثانیه طول می‌کشد.

**مشکل:**
در ساعات اوج کاری، کاربران زیادی به‌صورت همزمان به داشبورد مراجعه می‌کنند. در لحظه انقضای داده‌های کش، چندین درخواست همزمان باعث اجرای مجدد همان پردازش سنگین می‌شوند. نتیجه: افزایش شدید بار پردازنده و کاهش سرعت پاسخ‌گویی.

هدف شما طراحی و پیاده‌سازی یک مکانیزم **کش مقاوم و هوشمند** است که از این وضعیت جلوگیری کند.

---

## قوانین و محدودیت‌ها

1. از `IMemoryCache` برای کش داده‌های داشبورد استفاده کنید.
2. داده‌ها باید به مدت **۱ ساعت** در کش معتبر باشند.
3. اگر داده قبل از انقضا خوانده شود، **اعتبار آن ۳۰ دقیقه از زمان خواندن تمدید شود.**
4. در صورت انقضای کش، فقط **یک درخواست** مجاز به بازسازی داده است.
5. استفاده از کش‌های خارجی مانند Redis یا Memcached مجاز نیست.
6. تمرکز اصلی باید بر منطق کش و کنترل همزمانی باشد، نه طراحی رابط کاربری.

---

## نمونه رفتار مورد انتظار

1. کاربر A داده داشبورد را درخواست می‌کند → کش خالی است → پردازش سنگین اجرا و داده برای ۱ ساعت ذخیره می‌شود.
2. کاربر B پنج دقیقه بعد درخواست می‌دهد → داده از کش خوانده می‌شود → پاسخ سریع.
3. نزدیک زمان انقضا، چند کاربر همزمان درخواست می‌دهند → داده قبلی بازگردانده می‌شود و تنها یک درخواست داده جدید تولید می‌کند.
4. هر بار خواندن موفق، زمان انقضا را ۳۰ دقیقه تمدید می‌کند.

---

## نحوه اجرا و تست

### ۱) کلون پروژه

```bash
git clone https://github.com/dotin-challenge/dashboard-cache.git
cd dashboard-cache
```

### ۲) ساخت و اجرا

#### ▶ C#

```bash
dotnet build
dotnet run
```

### ۳) شبیه‌سازی بار همزمان (اختیاری)

```bash
ab -n 100 -c 10 http://localhost:5000/dashboard
```

---

## نحوه ارسال (PR)

1. ریپو را **Fork** کنید.
2. یک برنچ جدید بسازید:

   ```bash
   git checkout -b solution/<username>
   ```
3. کد خود را در مسیر زیر قرار دهید:

   ```text
   solutions/C#/<username>/
     ├─ Program.cs
     └─ README.md
   ```
4. مثال:

   ```text
   solutions/C#/ali-dev/
     ├─ Program.cs
     └─ README.md
   ```
5. یک Pull Request با عنوان زیر باز کنید:

   ```text
   [Solution] بهینه‌سازی سرویس داشبورد پربازدید - <username>
   ```

---

## معیارهای ارزیابی

| معیار                    | درصد   |
| ------------------------ | ------ |
| درستی عملکرد             | 40%    |
| کیفیت و خوانایی کد       | 25%    |
| مدیریت همزمانی و خطا     | 10%    |
| عملکرد و رفتار کش        | 10%    |
| مستندسازی                | 5%     |
| **سرعت ارسال (زمان PR)** | **5%** |

> هر چه زودتر یک PR صحیح و کامل قبل از ددلاین ارسال کنید، شانس بیشتری برای دریافت ۵٪ امتیاز اضافه خواهید داشت.

---

## زمان‌بندی

* شروع: `2025-11-26`
* پایان: `2025-12-02`

---

## راه‌های ارتباطی

* **ایجاد Issue در گیت‌هاب**
* **گروه انجمن دات‌نت**

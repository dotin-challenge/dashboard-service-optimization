# بهینه‌سازی سرویس داشبورد پرترافیک

[![Difficulty](https://img.shields.io/badge/difficulty-medium-orange)]()
[![Languages](https://img.shields.io/badge/languages-C%23-informational)]()
[![Deadline](https://img.shields.io/badge/deadline-1404--08--11-critical)]()

> خلاصه نتایج (2025-11-08): سه PR برتر — 1) #13 (82.5، HamedMortezaee)، 2) #1 (82.25، arash-mosavi)، 3) #2 (80.0، ShahramAfshar). گزارش کامل انگلیسی: [result.md](result.md). گزارش کامل فارسی: [result.fa.md](result.fa.md).

> طراحی یک راهبرد کش مقاوم برای سرویس داشبورد پرترافیک تا هنگام انقضای کش، از هجوم همزمان درخواست‌ها و محاسبات سنگین جلوگیری شود.

---

## فهرست مطالب

- [بهینه‌سازی سرویس داشبورد پرترافیک](#بهینهسازی-سرویس-داشبورد-پرترافیک)
  - [فهرست مطالب](#فهرست-مطالب)
  - [پیش‌نیازها](#پیشنیازها)
  - [توصیف مسئله](#توصیف-مسئله)
  - [قوانین و محدودیت‌ها](#قوانین-و-محدودیتها)
  - [نمونه رفتار](#نمونه-رفتار)
  - [نحوه اجرا و تست](#نحوه-اجرا-و-تست)
    - [۱) کلون پروژه](#۱-کلون-پروژه)
    - [۲) بیلد و اجرا](#۲-بیلد-و-اجرا)
    - [۳) شبیه‌سازی بار همزمان (اختیاری)](#۳-شبیهسازی-بار-همزمان-اختیاری)
  - [نحوه ارسال (PR)](#نحوه-ارسال-pr)
  - [معیارهای ارزیابی](#معیارهای-ارزیابی)
  - [زمان‌بندی](#زمانبندی)
  - [تماس](#تماس)

---

## پیش‌نیازها

* زبان مجاز: **C#**
* نسخه پیشنهادی: .NET 6+
* سیستم‌عامل: هرکدام (Windows / Linux / macOS)
* آشنایی با:
  * کش درون‌حافظه‌ای با IMemoryCache
  * ایمنی در برابر همزمانی (Thread‑safety) و کنترل همزمانی
  * راه‌اندازی ساده API یا برنامه کنسولی

---

## توصیف مسئله

شما برنامه‌نویس بک‌اند در یک شرکت نرم‌افزاری Enterprise هستید. یکی از پرکاربردترین بخش‌ها، سرویس داشبوردی است که داده‌های تحلیلی کلیدی را نمایش می‌دهد. تولید این داده‌ها شامل محاسبات سنگینی است که چند ثانیه زمان می‌برد.

مشکل: در ساعات اوج، کاربران زیادی همزمان به داشبورد دسترسی دارند. وقتی کش منقضی می‌شود، چندین درخواست همزمان باعث اجرای مجدد همان محاسبه سنگین می‌شوند و فشار روی CPU و کارایی را کاهش می‌دهند.

هدف شما طراحی و پیاده‌سازی یک مکانیزم کش مقاوم است که از چنین افت کارایی جلوگیری کند.

---

## قوانین و محدودیت‌ها

1. از IMemoryCache برای کش استفاده کنید.
2. دادهٔ کش‌شده باید برای **۱ ساعت** معتبر باشد.
3. اگر قبل از انقضا به داده دسترسی شد، **اعتبار آن ۳۰ دقیقه از زمان خواندن** تمدید شود (Sliding behavior).
4. از مشکل Cache Stampede جلوگیری کنید — هنگام انقضا تنها **یک درخواست** محاسبه مجدد انجام دهد.
5. استفاده از کش‌های توزیع‌شده خارجی (Redis, Memcached, …) مجاز نیست.
6. تمرکز روی کارایی و درستی بک‌اند است — نه UI/فرانت.

---

## نمونه رفتار

سناریو:
1. کاربر A درخواست می‌زند → کش Miss → محاسبه سنگین → نتیجه برای ۱ ساعت کش می‌شود.
2. کاربر B پنج دقیقه بعد → کش Hit → پاسخ فوری.
3. نزدیک انقضای کش، چند کاربر همزمان درخواست می‌زنند → فقط **یکی** داده جدید را تولید می‌کند.
4. هر خواندن موفق، اعتبار کش را ۳۰ دقیقه تمدید می‌کند.

---

## نحوه اجرا و تست

### ۱) کلون پروژه

`ash
git clone https://github.com/dotin-challenge/dashboard-service-optimization.git
cd dashboard-cache
`

### ۲) بیلد و اجرا

`ash
dotnet build
dotnet run
`

### ۳) شبیه‌سازی بار همزمان (اختیاری)

`ash
ab -n 100 -c 10 http://localhost:5000/dashboard
`

---

## نحوه ارسال (PR)

1. مخزن را **Fork** کنید.
2. یک شاخه جدید بسازید:
   `ash
   git checkout -b solution/<username>
   `
3. راهکار خود را در این مسیر قرار دهید:
   `	ext
   solutions/C#/<username>/
     ├── Program.cs
     └── README.md
   `
4. مثال:
   `	ext
   solutions/C#/john-doe/
     ├── Program.cs
     └── README.md
   `
5. یک Pull Request با عنوان زیر باز کنید:
   `	ext
   [Solution] High-Traffic Dashboard Optimization - <username>
   `

---

## معیارهای ارزیابی

| معیار                         | وزن |
|-------------------------------|-----|
| درستی پیاده‌سازی              | 40% |
| کیفیت و خوانایی کد            | 25% |
| همزمانی و مدیریت خطا         | 10% |
| کارایی و رفتار کش            | 10% |
| مستندسازی                    | 5%  |
| سرعت ارسال (زمان PR)         | 5%  |

> هرچه زودتر یک PR درست و کارا قبل از مهلت ارسال شود، شانس دریافت این ۵٪ بیشتر است (به‌صورت گسسته ۱۰۰/۷۰/۴۰ برای سه نفر اول).

---

## زمان‌بندی

* شروع: 2025-10-26
* مهلت: 2025-11-02

---

## تماس

* **GitHub Issues**
* **.NET Community Group**
